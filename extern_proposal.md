# Proposal: `extern`

Sometimes you want to modify the syntax tree to _slightly_
deviate from the grammar.
To do this, you currently must redefine an _entire_ AST data
structure and write a lot of trivial conversion boilerplate.
The only code of interest would be the 1% you modify.

## Motivating scenario

The grammar below describes the language of zero or more comma separated numbers.

```kiki
start OptNumbers

enum OptNumbers {
    None
    Some(Numbers)
}

enum Numbers {
    One($Number)
    Cons(Numbers _:$Comma $Number)
}

terminal Token {
    $Number: i32
    $Comma: ()
}
```

This generates (roughly) the following Rust code.
We make some simplifications.

```rust
pub enum OptNumbers {
    None,
    Some(Numbers),
}

pub enum Numbers {
    One(i32),
    Cons(Box<Numbers>, i32),
}

pub enum Token {
    Number(i32),
    Comma(()),
}

pub fn parse<I>(iter: I) -> Result<OptNumbers, Token>
where I: IntoIterator<Item = Token> {
    // ...
}
```

The `OptNumbers` type is a bit awkward to deal with.
A`Vec<i32>` would be ideal.
To do this, we write something like:

```rust
mod ast {
    pub struct OptNumbers(pub Vec<i32>);

    impl From<cst::OptNumbers> for OptNumbers {
        fn from(node: cst::OptNumbers) -> Self {
            match node {
                cst::OptNumbers::None => Self(vec![]),
                // We use `from` instead of `into` for clarity.
                cst::OptNumbers::Some(x) => Self::from(x),
            }
        }
    }

    impl From<cst::Numbers> for OptNumbers {
        fn from(node: cst::Numbers) -> Self {
            match node {
                cst::OptNumbers::One(n) => Self(vec![n]),
                cst::OptNumbers::Cons(left, last) => {
                    let mut left = Self::from(left);
                    left.push(last);
                    left
                },
            }
        }
    }
}
```

This isn't too bad so far.
The real problem starts when this is a small part of a larger language.
For example:

```kiki
start Expr

enum Expr {
    Sequence(SequenceExpr)
    String(StringExpr)
    Bool(BoolExpr)
    // ...
}

struct SequenceExpr {
    _: $SequenceKw
    OptNumbers
    _: $Semicolon
}

// ...
```

Then you'd have to write:

```rust
mod ast {
    // ...continued...

    pub enum Expr {
        Sequence(SequenceExpr),
        String(StringExpr),
        Bool(BoolExpr),
    }

    impl From<cst::Expr> for Expr {
        // ...
    }

    impl From<cst::SequenceExpr> for SequenceExpr {
        // ...
    }

    // ...
}
```

As you can see, there is a "cascade effect".
Since you create an AST version of `cst::OptNumbers`,
any node CST node that could have `cst::OptNumbers` as a descendant
will _also_ require an AST version.

## Solution

1. The user uses the `extern` keyword to
   tell Kiki to use some custom data structure `X`
   in place of `OptNumbers`.
2. The user specifies the grammar of `X` via a _builder_ `Y`.
3. The user is responsible for `impl From<Y> for X`.

## Example:

`numbers.kiki`:

```kiki
start OptNumbers

extern OptNumbers: crate::OptNumbers <- OptNumbersBuilder


enum OptNumbersBuilder {
    None
    Some(Numbers)
}

enum Numbers {
    One($Number)
    Cons(Numbers _:$Comma $Number)
}

terminal Token {
    $Number: i32
    $Comma: ()
}
```

`src/numbers.rs` (generated by Kiki):

```rust
use crate::OptNumbers;

pub enum OptNumbersBuilder {
    None,
    Some(Numbers),
}

pub enum Numbers {
    One(i32),
    Cons(Box<Numbers>, i32),
}

pub enum Token {
    Number(i32),
    Comma(()),
}

pub fn parse<I>(iter: I) -> Result<OptNumbers, Token>
where I: IntoIterator<Item = Token> {
    // ...
}
```

`src/lib.rs` (written by devloper):

```rust
pub struct OptNumbers(pub Vec<i32>);

impl From<numbers::OptNumbersBuilder> for OptNumbers {
    // ...
}

// ...
```
