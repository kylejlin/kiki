use crate::cst::*;

grammar;

// TODO: Delete
pub Term: i32 = {
    <n:Underscore> => 0,
    <n:Ident> => 1,
    <n:TerminalIdent> => 2,
    "(" <t:Term> ")" => t,
};

pub File: File = {
    <items:OptItems> => File { items },
};

pub OptItems: OptItems = {
    <Epsilon> => OptItems::Nil,
    <items:OptItems> <item:Item> => OptItems::Cons(Box::new(items), item),
};

pub Item: Item = {
    <start:Start> => Item::Start(start),
    <struct_:Struct> => Item::Struct(struct_),
    <enum_:Enum> => Item::Enum(enum_),
    <terminal:Terminal> => Item::Terminal(terminal),
};

pub Start: Ident = {
    <_drop:StartKw> <name:Ident> => name,
};

pub Struct: Struct = {
    <_drop:StructKw> <name:Ident> <fieldset:Fieldset> => Struct { name, fieldset },
};

pub Enum: Enum = {
    <_drop:EnumKw> <name:Ident> <_drop2:LCurly> <variants:OptEnumVariants> <_drop3:RCurly> => Enum {
        name,
        variants,
    },
};

pub Terminal: Terminal = {
    <_drop:TerminalKw> <name:TerminalIdent> <_drop2:LCurly> <variants:OptTerminalVariants> <_drop3:RCurly> => {
        Terminal { name, variants }
    },
};

pub Fieldset: Fieldset = {
    <_drop:Epsilon> => Fieldset::Empty,
    <_drop:LCurly> <fields:NamedFields> <_drop2:RCurly> => Fieldset::Named(NamedFieldset { fields }),
    <_drop:LParen> <fields:TupleFields> <_drop2:RParen> => Fieldset::Tuple(TupleFieldset { fields }),
};

pub NamedFields: NamedFields = {
    <field:NamedField> => NamedFields::One(field),
    <left:NamedFields> <_drop:Comma> <right:NamedField> => NamedFields::Mul(Box::new(left), right),
};

pub NamedField: NamedField = {
    <name:IdentOrUnderscore> <_drop:Colon> <symbol:IdentOrTerminalIdent> => NamedField { name, symbol },
};

pub TupleFields: TupleFields = {
    <field:TupleField> => TupleFields::One(field),
    <left:TupleFields> <_drop:Comma> <right:TupleField> => TupleFields::Cons(Box::new(left), right),
};

pub TupleField: TupleField = {
    <symbol:IdentOrTerminalIdent> => TupleField::Used(symbol),
    <_drop:Underscore> <_drop2:Colon> <symbol:IdentOrTerminalIdent> => TupleField::Skipped(symbol),
};

pub OptEnumVariants: OptEnumVariants = {
    <Epsilon> => OptEnumVariants::Nil,
    <left:OptEnumVariants> <right:EnumVariant> => OptEnumVariants::Cons(Box::new(left), right),
};

pub EnumVariant: EnumVariant = {
    <name:Ident> <fieldset:Fieldset> => EnumVariant { name, fieldset },
};

pub OptTerminalVariants: OptTerminalVariants = {
    <Epsilon> => OptTerminalVariants::Nil,
    <left:OptTerminalVariants> <right:TerminalVariant> => OptTerminalVariants::Cons(Box::new(left), right),
};

pub TerminalVariant: TerminalVariant = {
    <name:TerminalIdent> <_drop:Colon> <type_:Type> => TerminalVariant { name, type_ },
};

pub Type: Type = {
    <_drop:LParen> <_drop2:RParen> => Type::Unit,
    <path:Path> => Type::Path(path),
    <complex:ComplexType> => Type::Complex(Box::new(complex)),
};

pub Path: Path = {
    <name:Ident> => Path::One(name),
    <left:Path> <_drop:DoubleColon> <right:Ident> => Path::Cons(Box::new(left), right),
};

pub ComplexType: ComplexType = {
    <callee:Type> <_drop:LAngle> <types:CommaSeparatedTypes> <_drop2:RAngle> => ComplexType {
        callee,
        types,
    },
};

pub CommaSeparatedTypes: CommaSeparatedTypes = {
    <type_:Type> => CommaSeparatedTypes::One(type_),
    <left:CommaSeparatedTypes> <_drop:Comma> <right:Type> => CommaSeparatedTypes::Cons(Box::new(left), right),
};

pub IdentOrUnderscore: IdentOrUnderscore = {
    <ident:Ident> => IdentOrUnderscore::Ident(ident),
    <_drop:Underscore> => IdentOrUnderscore::Underscore,
};

pub IdentOrTerminalIdent: IdentOrTerminalIdent = {
    <ident:Ident> => IdentOrTerminalIdent::Ident(ident),
    <terminal:TerminalIdent> => IdentOrTerminalIdent::Terminal(terminal),
};

pub StartKw: () = "start" => ();
pub StructKw: () = "struct" => ();
pub EnumKw: () = "enum" => ();
pub TerminalKw: () = "terminal" => ();

pub DoubleColon: () = "::" => ();
pub Colon: () = ":" => ();
pub Comma: () = "," => ();

pub LParen: () = "(" => ();
pub RParen: () = ")" => ();
pub LCurly: () = "{" => ();
pub RCurly: () = "}" => ();
pub LAngle: () = "<" => ();
pub RAngle: () = ">" => ();

pub Underscore: () = "_" => ();

pub Ident: Ident = <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => Ident {
    name: s.to_owned(),
    // TODO
    position: ByteIndex(0),
};
pub TerminalIdent: TerminalIdent = <s:r"\$[a-zA-Z_][a-zA-Z_0-9]*"> => TerminalIdent {
    name: s.to_owned(),
    // TODO
    position: ByteIndex(0),
};

#[inline]
Epsilon: () = ();
