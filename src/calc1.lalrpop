use crate::cst::*;

grammar;

// ```kiki
// start File

// struct File {
//     items: OptItems
// }

// enum OptItems {
//     Nil
//     Cons(
//         OptItems
//         Item
//     )
// }

// enum Item {
//     Start(
//         _: $StartKw
//         $Ident
//     )
//     Struct(Struct)
//     Enum(Enum)
//     Terminal(Terminal)
// }

// struct Struct {
//     _: $StructKw
//     name: $Ident
//     fieldset: Fieldset
// }

// struct Enum {
//     _: $EnumKw
//     name: $Ident
//     _: $LCurly
//     variants: OptEnumVariants
//     _: $RCurly
// }

// struct Terminal {
//     _: $TerminalKw
//     name: $Ident
//     _: $LCurly
//     variants: OptTerminalVariants
//     _: $RCurly
// }

// enum Fieldset {
//     Empty
//     Named(NamedFieldset)
//     Tuple(TupleFieldset)
// }

// struct NamedFieldset {
//     _: $LCurly
//     fields: NamedFields
//     _: $RCurly
// }

// enum NamedFields {
//     One(NamedField)
//     Mul {
//         left: NamedFields
//         right: NamedField
//     }
// }

// struct NamedField {
//     name: IdentOrUnderscore
//     _: $Colon
//     symbol: IdentOrTerminalIdent
// }

// struct TupleFieldset {
//     _: $LParen
//     fields: TupleFields
//     _: $RParen
// }

// enum TupleFields {
//     One(TupleField)
//     Cons {
//         left: TupleFields
//         right: TupleField
//     }
// }

// enum TupleField {
//     Used(IdentOrTerminalIdent)
//     Skipped(
//         _: $Underscore
//         _: $Colon
//         IdentOrTerminalIdent
//     )
// }

// enum OptEnumVariants {
//     Nil
//     Cons {
//         left: OptEnumVariants
//         right: EnumVariant
//     }
// }

// struct EnumVariant {
//     name: $Ident
//     fields: Fieldset
// }

// enum OptTerminalVariants {
//     Nil
//     Cons {
//         left: OptTerminalVariants
//         right: TerminalVariant
//     }
// }

// struct TerminalVariant {
//     name: $TerminalIdent
//     _: $Colon
//     type_: Type
// }

// enum Type {
//     Unit(
//         _: $LParen
//         _: $RParen
//     )
//     Path(Path)
//     Complex(ComplexType)
// }

// enum Path {
//     One($Ident)
//     Cons {
//         left: Path
//         _: $DoubleColon
//         right: $Ident
//     }
// }

// struct ComplexType {
//     callee: Type
//     _: $LAngle
//     Types
//     _: $RAngle
// }

// enum CommaSeparatedTypes {
//     One(Type)
//     Cons {
//         left: CommaSeparatedTypes
//         _: $Comma
//         right: Type
//     }
// }

// enum IdentOrUnderscore {
//     Ident($Ident)
//     Underscore($Underscore)
// }

// enum IdentOrTerminalIdent {
//     Ident($Ident)
//     Terminal($TerminalIdent)
// }
// ```

// TODO: Delete
pub Term: i32 = {
    <n:Underscore> => 0,
    <n:Ident> => 1,
    <n:TerminalIdent> => 2,
    "(" <t:Term> ")" => t,
};

pub File: File = {
    <items:OptItems> => File { items },
};

// TODO
pub OptItems: OptItems = {
    "" => OptItems::Nil,
};

pub StartKw: () = "start" => ();
pub StructKw: () = "struct" => ();
pub EnumKw: () = "enum" => ();
pub TerminalKw: () = "terminal" => ();

pub DoubleColon: () = "::" => ();
pub Colon: () = ":" => ();
pub Comma: () = "," => ();

pub LParen: () = "(" => ();
pub RParen: () = ")" => ();
pub LCurly: () = "{" => ();
pub RCurly: () = "}" => ();
pub LAngle: () = "<" => ();
pub RAngle: () = ">" => ();

pub Underscore: () = "_" => ();

pub Ident: Ident = <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => Ident {
    name: s.to_owned(),
    // TODO
    position: ByteIndex(0),
};
pub TerminalIdent: TerminalIdent = <s:r"\$[a-zA-Z_][a-zA-Z_0-9]*"> => TerminalIdent {
    name: s.to_owned(),
    // TODO
    position: ByteIndex(0),
};
