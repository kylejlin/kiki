---
source: src/pipeline/table_to_rust.rs
expression: rust_src
---
"// This code was generated by Kiki.\n\n#[derive(Debug)]\npub enum Token {\n    LParen(()),\n    RParen(()),\n}\n\n#[derive(Clone, Debug)]\npub enum Expr {\n    Empty,\n    Wrap {\n        inner: Box<Expr>,\n        right: (),\n    },\n}\n\n/// If the parser encounters an unexpected token `t`, it will return `Err(Some(t))`.\n/// If the parser encounters an unexpected end of input, it will return `Err(None)`.\npub fn parse<S>(src: S) -> Result<Expr, Option<Token>>\nwhere S: IntoIterator<Item = Token> {\n    let mut quasiterminals = src.into_iter()\n        .map(Quasiterminal::Terminal)\n        .chain(std::iter::once(Quasiterminal::Eof))\n        .peekable();\n    let mut states = vec![State::S0];\n    let mut nodes: Vec<Node> = vec![];\n    loop {\n        let top_state = *states.last().unwrap();\n        let next_quasiterminal_kind = QuasiterminalKind::from_quasiterminal(quasiterminals.peek().unwrap());\n        match get_action(top_state, next_quasiterminal_kind) {\n            Action::Shift(new_state) => {\n                states.push(new_state);\n                nodes.push(Node::from_terminal(quasiterminals.next().unwrap().try_into_terminal().unwrap()));\n            }\n\n            Action::Reduce(rule_kind) => {\n                let (new_node, new_node_kind) = pop_and_reduce(&mut states, &mut nodes, rule_kind);\n                nodes.push(new_node);\n                let temp_top_state = *states.last().unwrap();\n                let Some(new_state) = get_goto(temp_top_state, new_node_kind) else {\n                    return Err(quasiterminals.next().unwrap().try_into_terminal().ok());\n                };\n                states.push(new_state);\n            }\n\n            Action::Accept => {\n                return Ok(Expr::try_from(nodes.pop().unwrap()).unwrap());\n            }\n\n            Action::Err => {\n                return Err(quasiterminals.next().unwrap().try_into_terminal().ok());\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Quasiterminal {\n    Terminal(Token),\n    Eof,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum QuasiterminalKind {\n    LParen = 0,\n    RParen = 1,\n    Eof = 2,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum NonterminalKind {\n    Expr = 0,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum State {\n    S0 = 0,\n    S1 = 1,\n    S2 = 2,\n    S3 = 3,\n    S4 = 4,\n}\n\n#[derive(Debug)]\nenum Node {\n    Expr(Expr),\n    LParen(()),\n    RParen(()),\n}\n\n#[derive(Clone, Copy, Debug)]\nenum Action {\n    Shift(State),\n    Reduce(RuleKind),\n    Accept,\n    Err,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum RuleKind {\n    R0 = 0,\n    R1 = 1,\n}\n\nfn pop_and_reduce(states: &mut Vec<State>, nodes: &mut Vec<Node>, rule_kind: RuleKind) -> (Node, NonterminalKind) {\n    match rule_kind {\n        RuleKind::R0 => {\n            (\n                Node::Expr(Expr::Empty),\n                NonterminalKind::Expr,\n            )\n        }\n        RuleKind::R1 => {\n            let right_2 = nodes.pop().unwrap().try_into_r_paren_1().unwrap();\n            let inner_1 = Box::new(Expr::try_from(nodes.pop().unwrap()).unwrap());\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 3);\n            \n            (\n                Node::Expr(Expr::Wrap {\n                    inner: inner_1,\n                    right: right_2,\n                }),\n                NonterminalKind::Expr\n            )\n        }\n    }\n}\n\nimpl QuasiterminalKind {\n    fn from_quasiterminal(quasiterminal: &Quasiterminal) -> Self {\n        match quasiterminal {\n            Quasiterminal::Terminal(terminal) => Self::from_terminal(terminal),\n            Quasiterminal::Eof => Self::Eof,\n        }\n    }\n\n    fn from_terminal(terminal: &Token) -> Self {\n        match terminal {\n            Token::LParen(_) => Self::LParen,\n            Token::RParen(_) => Self::RParen,\n        }\n    }\n}\n\nimpl Node {\n    fn from_terminal(terminal: Token) -> Self {\n        match terminal {\n            Token::LParen(t) => Self::LParen(t),\n            Token::RParen(t) => Self::RParen(t),\n        }\n    }\n}\n\nimpl Quasiterminal {\n    fn try_into_terminal(self) -> Result<Token, ()> {\n        match self {\n            Self::Terminal(terminal) => Ok(terminal),\n            Self::Eof => Err(()),\n        }\n    }\n}\n\nconst ACTION_TABLE: [[Action; 3]; 5] = [\n    [\n        Action::Shift(State::S2),\n        Action::Err,\n        Action::Reduce(RuleKind::R0),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Accept,\n    ],\n    [\n        Action::Shift(State::S2),\n        Action::Reduce(RuleKind::R0),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Shift(State::S4),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Reduce(RuleKind::R1),\n        Action::Reduce(RuleKind::R1),\n    ],\n];\n\nfn get_action(top_state: State, next_quasiterminal_kind: QuasiterminalKind) -> Action {\n    ACTION_TABLE[top_state as usize][next_quasiterminal_kind as usize]\n}\n\nconst GOTO_TABLE: [[Option<State>; 1]; 5] = [\n    [\n        Some(State::S1),\n    ],\n    [\n        None,\n    ],\n    [\n        Some(State::S3),\n    ],\n    [\n        None,\n    ],\n    [\n        None,\n    ],\n];\n\nfn get_goto(top_state: State, new_node_kind: NonterminalKind) -> Option<State> {\n    GOTO_TABLE[top_state as usize][new_node_kind as usize]\n}\n\nimpl TryFrom<Node> for Expr {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Expr(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl Node {\n    fn try_into_l_paren_0(self) -> Result<(), Self> {\n        match self {\n            Self::LParen(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_r_paren_1(self) -> Result<(), Self> {\n        match self {\n            Self::RParen(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n}\n"
