use crate::data::cst::*;
use crate::data::{ByteIndex, DollarlessTerminalName};

grammar;

match {
    r"//[^\n]*" => {},
    r"\s+" => {}
} else {
    _
}

pub File: File = {
    <items:OptItems> => File { items },
};

pub OptItems: OptItems = {
    <Epsilon> => OptItems::Nil,
    <items:OptItems> <item:FileItem> => OptItems::Cons(Box::new(items), item),
};

pub FileItem: FileItem = {
    <start:Start> => FileItem::Start(start),
    <struct_:Struct> => FileItem::Struct(struct_),
    <enum_:Enum> => FileItem::Enum(enum_),
    <terminal:Terminal> => FileItem::Terminal(terminal),
};

pub Start: Ident = {
    <_drop:StartKw> <name:Ident> => name,
};

pub Struct: Struct = {
    <_drop:StructKw> <name:Ident> <fieldset:Fieldset> => Struct { name, fieldset },
};

pub Enum: Enum = {
    <_drop:EnumKw> <name:Ident> <_drop2:LCurly> <variants:OptEnumVariants> <_drop3:RCurly> => Enum {
        name,
        variants,
    },
};

pub Terminal: TerminalEnum = {
    <_drop:TerminalKw> <name:Ident> <_drop2:LCurly> <variants:OptTerminalEnumVariants> <_drop3:RCurly> => {
        TerminalEnum { name, variants }
    },
};

pub Fieldset: Fieldset = {
    <_drop:Epsilon> => Fieldset::Empty,
    <_drop:LCurly> <fields:NamedFields> <_drop2:RCurly> => Fieldset::Named(NamedFieldset { fields }),
    <_drop:LParen> <fields:TupleFields> <_drop2:RParen> => Fieldset::Tuple(TupleFieldset { fields }),
};

pub NamedFields: NamedFields = {
    <field:NamedField> => NamedFields::One(field),
    <left:NamedFields> <right:NamedField> => NamedFields::Cons(Box::new(left), right),
};

pub NamedField: NamedField = {
    <name:IdentOrUnderscore> <_drop:Colon> <symbol:IdentOrTerminalIdent> => NamedField { name, symbol },
};

pub TupleFields: TupleFields = {
    <field:TupleField> => TupleFields::One(field),
    <left:TupleFields> <right:TupleField> => TupleFields::Cons(Box::new(left), right),
};

pub TupleField: TupleField = {
    <symbol:IdentOrTerminalIdent> => TupleField::Used(symbol),
    <_drop:Underscore> <_drop2:Colon> <symbol:IdentOrTerminalIdent> => TupleField::Skipped(symbol),
};

pub OptEnumVariants: OptEnumVariants = {
    <Epsilon> => OptEnumVariants::Nil,
    <left:OptEnumVariants> <right:EnumVariant> => OptEnumVariants::Cons(Box::new(left), right),
};

pub EnumVariant: EnumVariant = {
    <name:Ident> <fieldset:Fieldset> => EnumVariant { name, fieldset },
};

pub OptTerminalEnumVariants: OptTerminalEnumVariants = {
    <Epsilon> => OptTerminalEnumVariants::Nil,
    <left:OptTerminalEnumVariants> <right:TerminalEnumVariant> => OptTerminalEnumVariants::Cons(Box::new(left), right),
};

pub TerminalEnumVariant: TerminalEnumVariant = {
    <name:TerminalIdent> <_drop:Colon> <type_:Type> => TerminalEnumVariant { name, type_ },
};

pub Type: Type = {
    <_drop:LParen> <_drop2:RParen> => Type::Unit,
    <path:Path> => Type::Path(path),
    <complex:ComplexType> => Type::Complex(Box::new(complex)),
};

pub Path: Path = {
    <name:Ident> => Path::One(name),
    <left:Path> <_drop:DoubleColon> <right:Ident> => Path::Cons(Box::new(left), right),
};

pub ComplexType: ComplexType = {
    <callee:Path> <_drop:LAngle> <args:CommaSeparatedTypes> <_drop2:RAngle> => ComplexType {
        callee,
        args,
    },
};

pub CommaSeparatedTypes: CommaSeparatedTypes = {
    <type_:Type> => CommaSeparatedTypes::One(type_),
    <left:CommaSeparatedTypes> <_drop:Comma> <right:Type> => CommaSeparatedTypes::Cons(Box::new(left), right),
};

pub IdentOrUnderscore: IdentOrUnderscore = {
    <ident:Ident> => IdentOrUnderscore::Ident(ident),
    <_drop:Underscore> => IdentOrUnderscore::Underscore,
};

pub IdentOrTerminalIdent: IdentOrTerminalIdent = {
    <ident:Ident> => IdentOrTerminalIdent::Ident(ident),
    <terminal:TerminalIdent> => IdentOrTerminalIdent::Terminal(terminal),
};

pub StartKw: () = "start" => ();
pub StructKw: () = "struct" => ();
pub EnumKw: () = "enum" => ();
pub TerminalKw: () = "terminal" => ();

pub DoubleColon: () = "::" => ();
pub Colon: () = ":" => ();
pub Comma: () = "," => ();

pub LParen: () = "(" => ();
pub RParen: () = ")" => ();
pub LCurly: () = "{" => ();
pub RCurly: () = "}" => ();
pub LAngle: () = "<" => ();
pub RAngle: () = ">" => ();

pub Underscore: () = "_" => ();

pub Ident: Ident = <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => Ident {
    name: s.to_owned(),
    // TODO
    position: ByteIndex(0),
};
pub TerminalIdent: TerminalIdent = <s:r"\$[a-zA-Z_][a-zA-Z_0-9]*"> => TerminalIdent {
    name: DollarlessTerminalName::remove_dollars(s),
    // TODO
    dollarless_position: ByteIndex(1),
};

#[inline]
Epsilon: () = ();
