---
source: src/logic/table_to_rust.rs
expression: rust_src
---
"// This code was generated by Kiki.\n\n#[derive(Debug)]\nenum Quasitoken {\n    Token(Token),\n    Eof,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum QuasitokenKind {\n    LParen = 0,\n    RParen = 1,\n    Eof = 2,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum NonterminalKind {\n    Expr = 0,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum State {\n    S0 = 0,\n    S1 = 1,\n    S2 = 2,\n    S3 = 3,\n    S4 = 4,\n}\n\n#[derive(Debug)]\nenum Node {\n    Expr(Expr),\n    LParen(()),\n    RParen(()),\n}\n\n#[derive(Clone, Copy, Debug)]\nenum Action {\n    Shift(State),\n    Reduce(RuleKind),\n    Accept,\n    Err,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum RuleKind {\n    R0 = 0,\n    R1 = 1,\n}\n\n/// If the parser encounters an unexpected token `t`, it will return `Err(Some(t))`.\n/// If the parser encounters an unexpected end of input, it will return `Err(None)`.\npub fn parse<S>(src: S) -> Result<Expr, Option<Token>>\nwhere S: IntoIterator<Item = Token> {\n    let mut tokens = src.into_iter()\n        .map(Quasitoken::Token)\n        .chain(std::iter::once(Quasitoken::Eof))\n        .peekable();\n    let mut states = vec![State::S0];\n    let mut nodes: Vec<Node> = vec![];\n    loop {\n        let top_state = *states.last().unwrap();\n        let next_quasitoken_kind = QuasitokenKind::from_quasitoken(tokens.peek().unwrap());\n        match get_action(top_state, next_quasitoken_kind) {\n            Action::Shift(new_state) => {\n                states.push(new_state);\n                nodes.push(Node::from_token(tokens.next().unwrap().try_into_token().unwrap()));\n            }\n\n            Action::Reduce(rule_kind) => {\n                let (new_node, new_node_kind) = pop_and_reduce(&mut states, &mut nodes, rule_kind);\n                nodes.push(new_node);\n                let temp_top_state = *states.last().unwrap();\n                let Some(new_state) = get_goto(temp_top_state, new_node_kind) else {\n                    return Err(tokens.next().unwrap().try_into_token().ok());\n                };\n                states.push(new_state);\n            }\n\n            Action::Accept => {\n                return Ok(Expr::try_from(nodes.pop().unwrap()).unwrap());\n            }\n\n            Action::Err => {\n                return Err(tokens.next().unwrap().try_into_token().ok());\n            }\n        }\n    }\n}\n\nfn pop_and_reduce(states: &mut Vec<State>, nodes: &mut Vec<Node>, rule_kind: RuleKind) -> (Node, NonterminalKind) {\n    match rule_kind {\n        RuleKind::R0 => {\n            (\n                Node::Expr(Expr::Empty),\n                NonterminalKind::Expr,\n            )\n        }\n        RuleKind::R1 => {\n            let t2 = nodes.pop().unwrap().try_into_r_paren_1().unwrap();\n            let t1 = Expr::try_from(nodes.pop().unwrap()).unwrap();\n            let t0 = nodes.pop().unwrap().try_into_l_paren_0().unwrap();\n            \n            (\n                Node::Expr(Expr::Wrap(\n                    t0,\n                    t1,\n                    t2,\n                )),\n                NonterminalKind::Expr\n            )\n        }\n    }\n}\n\nimpl QuasitokenKind {\n    fn from_quasitoken(quasitoken: &Quasitoken) -> Self {\n        match quasitoken {\n            Quasitoken::Token(token) => Self::from_token(token),\n            Quasitoken::Eof => Self::Eof,\n        }\n    }\n\n    fn from_token(token: &Token) -> Self {\n        match token {\n            Token::LParen(_) => Self::LParen,\n            Token::RParen(_) => Self::RParen,\n        }\n    }\n}\n\nimpl Node {\n    fn from_token(token: Token) -> Self {\n        match token {\n            Token::LParen(t) => Self::LParen(t),\n            Token::RParen(t) => Self::RParen(t),\n        }\n    }\n}\n\nimpl Quasitoken {\n    fn try_into_token(self) -> Result<Token, ()> {\n        match self {\n            Self::Token(token) => Ok(token),\n            Self::Eof => Err(()),\n        }\n    }\n}\n\nconst ACTION_TABLE: [[Action; 3]; 5] = [\n    [\n        Action::Shift(State::S2),\n        Action::Err,\n        Action::Reduce(RuleKind::R1),\n    ],\n    [\n        Action::Reduce(RuleKind::R1),\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Accept,\n        Action::Shift(State::S2),\n    ],\n    [\n        Action::Shift(State::S2),\n        Action::Reduce(RuleKind::R1),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Shift(State::S4),\n    ],\n];\n\nfn get_action(top_state: State, next_quasitoken_kind: QuasitokenKind) -> Action {\n    ACTION_TABLE[top_state as usize][next_quasitoken_kind as usize]\n}\n\nconst GOTO_TABLE: [[Option<State>; 1]; 5] = [\n    [\n        Some(State::S1),\n    ],\n    [\n        None,\n    ],\n    [\n        Some(State::S3),\n    ],\n    [\n        None,\n    ],\n    [\n        None,\n    ],\n];\n\nfn get_goto(top_state: State, new_node_kind: NonterminalKind) -> Option<State> {\n    GOTO_TABLE[top_state as usize][new_node_kind as usize]\n}\n\nimpl TryFrom<Node> for Expr {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Expr(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl Node {\n    fn try_into_l_paren_0(self) -> Result<(), Self> {\n        match self {\n            Self::LParen(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_r_paren_1(self) -> Result<(), Self> {\n        match self {\n            Self::RParen(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub enum Expr {\n    Empty,\n    Wrap(\n        (),\n        Expr,\n        (),\n    ),\n}\n"
