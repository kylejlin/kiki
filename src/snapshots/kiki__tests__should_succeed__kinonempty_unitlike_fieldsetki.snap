---
source: src/tests.rs
expression: rust_src
---
RustSrc(
    "// This code was generated by Kiki.\n// Kiki is an open-source minimalist parser generator for Rust.\n// You can read more at https://crates.io/crates/kiki\n//\n// This code was generated from a grammar with the following hash:\n// @sha256 f6176f7ea7b906a84d040468932bed981a6503efa72c10983e3c44be453ec264\n\n#[derive(Debug)]\npub enum Token {\n    String(String),\n    Number(isize),\n}\n\n#[derive(Clone, Debug)]\npub enum Foo {\n    Empty(\n        \n    ),\n    Number {\n        \n    },\n    Pair {\n        val: Box<Pair>,\n    },\n}\n\n#[derive(Clone, Debug)]\npub struct Epsilon;\n\n#[derive(Clone, Debug)]\npub enum Pair {\n    StringPair(\n        Box<StringPair>,\n    ),\n    NumberPair(\n        Box<NumberPair>,\n    ),\n}\n\n#[derive(Clone, Debug)]\npub struct StringPair {\n    \n}\n\n#[derive(Clone, Debug)]\npub struct NumberPair(\n    \n);\n\n/// If the parser encounters an unexpected token `t`, it will return `Err(Some(t))`.\n/// If the parser encounters an unexpected end of input, it will return `Err(None)`.\npub fn parse<S>(src: S) -> Result<Foo, Option<Token>>\nwhere S: IntoIterator<Item = Token> {\n    let mut quasiterminals = src.into_iter()\n        .map(Quasiterminal::Terminal)\n        .chain(std::iter::once(Quasiterminal::Eof))\n        .peekable();\n    let mut states = vec![State::S0];\n    let mut nodes: Vec<Node> = vec![];\n    loop {\n        let top_state = *states.last().unwrap();\n        let next_quasiterminal_kind = QuasiterminalKind::from_quasiterminal(quasiterminals.peek().unwrap());\n        match get_action(top_state, next_quasiterminal_kind) {\n            Action::Shift(new_state) => {\n                states.push(new_state);\n                nodes.push(Node::from_terminal(quasiterminals.next().unwrap().try_into_terminal().unwrap()));\n            }\n\n            Action::Reduce(rule_kind) => {\n                let (new_node, new_node_kind) = pop_and_reduce(&mut states, &mut nodes, rule_kind);\n                nodes.push(new_node);\n                let temp_top_state = *states.last().unwrap();\n                let Some(new_state) = get_goto(temp_top_state, new_node_kind) else {\n                    return Err(quasiterminals.next().unwrap().try_into_terminal().ok());\n                };\n                states.push(new_state);\n            }\n\n            Action::Accept => {\n                return Ok(Foo::try_from(nodes.pop().unwrap()).unwrap());\n            }\n\n            Action::Err => {\n                return Err(quasiterminals.next().unwrap().try_into_terminal().ok());\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Quasiterminal {\n    Terminal(Token),\n    Eof,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum QuasiterminalKind {\n    String = 0,\n    Number = 1,\n    Eof = 2,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum NonterminalKind {\n    Foo = 0,\n    Epsilon = 1,\n    Pair = 2,\n    StringPair = 3,\n    NumberPair = 4,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum State {\n    S0 = 0,\n    S1 = 1,\n    S2 = 2,\n    S3 = 3,\n    S4 = 4,\n    S5 = 5,\n    S6 = 6,\n    S7 = 7,\n    S8 = 8,\n    S9 = 9,\n}\n\n#[derive(Debug)]\nenum Node {\n    Foo(Foo),\n    Epsilon(Epsilon),\n    Pair(Pair),\n    StringPair(StringPair),\n    NumberPair(NumberPair),\n    String(String),\n    Number(isize),\n}\n\n#[derive(Clone, Copy, Debug)]\nenum Action {\n    Shift(State),\n    Reduce(RuleKind),\n    Accept,\n    Err,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum RuleKind {\n    R0 = 0,\n    R1 = 1,\n    R2 = 2,\n    R3 = 3,\n    R4 = 4,\n    R5 = 5,\n    R6 = 6,\n    R7 = 7,\n}\n\nfn pop_and_reduce(states: &mut Vec<State>, nodes: &mut Vec<Node>, rule_kind: RuleKind) -> (Node, NonterminalKind) {\n    match rule_kind {\n        RuleKind::R0 => {\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Foo(Foo::Empty(\n                    \n                )),\n                NonterminalKind::Foo\n            )\n        }\n        RuleKind::R1 => {\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Foo(Foo::Number {\n                    \n                }),\n                NonterminalKind::Foo\n            )\n        }\n        RuleKind::R2 => {\n            let val_0 = Box::new(Pair::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Foo(Foo::Pair {\n                    val: val_0,\n                }),\n                NonterminalKind::Foo\n            )\n        }\n        RuleKind::R3 => {\n            (\n                Node::Epsilon(Epsilon),\n                NonterminalKind::Epsilon,\n            )\n        }\n        RuleKind::R4 => {\n            let t0 = Box::new(StringPair::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Pair(Pair::StringPair(\n                    t0,\n                )),\n                NonterminalKind::Pair\n            )\n        }\n        RuleKind::R5 => {\n            let t0 = Box::new(NumberPair::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Pair(Pair::NumberPair(\n                    t0,\n                )),\n                NonterminalKind::Pair\n            )\n        }\n        RuleKind::R6 => {\n            nodes.pop().unwrap();\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 2);\n            \n            (\n                Node::StringPair(StringPair {\n                    \n                }),\n                NonterminalKind::StringPair\n            )\n        }\n        RuleKind::R7 => {\n            nodes.pop().unwrap();\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 2);\n            \n            (\n                Node::NumberPair(NumberPair(\n                    \n                )),\n                NonterminalKind::NumberPair\n            )\n        }\n    }\n}\n\nimpl QuasiterminalKind {\n    fn from_quasiterminal(quasiterminal: &Quasiterminal) -> Self {\n        match quasiterminal {\n            Quasiterminal::Terminal(terminal) => Self::from_terminal(terminal),\n            Quasiterminal::Eof => Self::Eof,\n        }\n    }\n\n    fn from_terminal(terminal: &Token) -> Self {\n        match terminal {\n            Token::String(_) => Self::String,\n            Token::Number(_) => Self::Number,\n        }\n    }\n}\n\nimpl Node {\n    fn from_terminal(terminal: Token) -> Self {\n        match terminal {\n            Token::String(t) => Self::String(t),\n            Token::Number(t) => Self::Number(t),\n        }\n    }\n}\n\nimpl Quasiterminal {\n    fn try_into_terminal(self) -> Result<Token, ()> {\n        match self {\n            Self::Terminal(terminal) => Ok(terminal),\n            Self::Eof => Err(()),\n        }\n    }\n}\n\nconst ACTION_TABLE: [[Action; 3]; 10] = [\n    [\n        Action::Shift(State::S6),\n        Action::Shift(State::S2),\n        Action::Reduce(RuleKind::R3),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R0),\n    ],\n    [\n        Action::Err,\n        Action::Shift(State::S8),\n        Action::Reduce(RuleKind::R1),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R2),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R4),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R5),\n    ],\n    [\n        Action::Shift(State::S7),\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R6),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R7),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Accept,\n    ],\n];\n\nfn get_action(top_state: State, next_quasiterminal_kind: QuasiterminalKind) -> Action {\n    ACTION_TABLE[top_state as usize][next_quasiterminal_kind as usize]\n}\n\nconst GOTO_TABLE: [[Option<State>; 5]; 10] = [\n    [\n        Some(State::S9),\n        Some(State::S1),\n        Some(State::S3),\n        Some(State::S4),\n        Some(State::S5),\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n];\n\nfn get_goto(top_state: State, new_node_kind: NonterminalKind) -> Option<State> {\n    GOTO_TABLE[top_state as usize][new_node_kind as usize]\n}\n\nimpl TryFrom<Node> for Foo {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Foo(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Epsilon {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Epsilon(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Pair {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Pair(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for StringPair {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::StringPair(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for NumberPair {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::NumberPair(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl Node {\n    fn try_into_string_0(self) -> Result<String, Self> {\n        match self {\n            Self::String(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_number_1(self) -> Result<isize, Self> {\n        match self {\n            Self::Number(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n}\n",
)
