---
source: src/tests.rs
expression: rust_src
---
RustSrc(
    "// This code was generated by Kiki.\n// Kiki is an open-source minimalist parser generator for Rust.\n// You can read more at https://crates.io/crates/kiki\n//\n// This code was generated from a grammar with the following hash:\n// @sha256 0887494eb5b928d9ebb0c4ae3b2475b5cdbea535d17e78bc7c0b66d06a4851c3\n\n#[derive(Debug)]\npub enum Token {\n    String(String),\n    Num(String),\n    Bool(String),\n    LCurly(String),\n    RCurly(String),\n    LSquare(String),\n    RSquare(String),\n    Colon(String),\n    Comma(String),\n}\n\n#[derive(Clone, Debug)]\npub enum Json {\n    Obj(\n        Box<Obj>,\n    ),\n    Arr(\n        Box<Arr>,\n    ),\n}\n\n#[derive(Clone, Debug)]\npub struct Obj {\n    entries: Box<OptEntries>,\n}\n\n#[derive(Clone, Debug)]\npub enum OptEntries {\n    None,\n    Some(\n        Box<Entries>,\n    ),\n}\n\n#[derive(Clone, Debug)]\npub enum Entries {\n    One(\n        Box<Entry>,\n    ),\n    Many(\n        Box<Entries>,\n        Box<Entry>,\n    ),\n}\n\n#[derive(Clone, Debug)]\npub struct Entry {\n    key: String,\n    val: Box<Expr>,\n}\n\n#[derive(Clone, Debug)]\npub enum Expr {\n    Obj(\n        Box<Obj>,\n    ),\n    Arr(\n        Box<Arr>,\n    ),\n    String(\n        String,\n    ),\n    Num(\n        String,\n    ),\n    Bool(\n        String,\n    ),\n}\n\n#[derive(Clone, Debug)]\npub struct Arr {\n    elements: Box<OptElements>,\n}\n\n#[derive(Clone, Debug)]\npub enum OptElements {\n    None,\n    Some(\n        Box<Elements>,\n    ),\n}\n\n#[derive(Clone, Debug)]\npub enum Elements {\n    One(\n        Box<Expr>,\n    ),\n    Many(\n        Box<Elements>,\n        Box<Expr>,\n    ),\n}\n\n/// If the parser encounters an unexpected token `t`, it will return `Err(Some(t))`.\n/// If the parser encounters an unexpected end of input, it will return `Err(None)`.\npub fn parse<S>(src: S) -> Result<Json, Option<Token>>\nwhere S: IntoIterator<Item = Token> {\n    let mut quasiterminals = src.into_iter()\n        .map(Quasiterminal::Terminal)\n        .chain(std::iter::once(Quasiterminal::Eof))\n        .peekable();\n    let mut states = vec![State::S0];\n    let mut nodes: Vec<Node> = vec![];\n    loop {\n        let top_state = *states.last().unwrap();\n        let next_quasiterminal_kind = QuasiterminalKind::from_quasiterminal(quasiterminals.peek().unwrap());\n        match get_action(top_state, next_quasiterminal_kind) {\n            Action::Shift(new_state) => {\n                states.push(new_state);\n                nodes.push(Node::from_terminal(quasiterminals.next().unwrap().try_into_terminal().unwrap()));\n            }\n\n            Action::Reduce(rule_kind) => {\n                let (new_node, new_node_kind) = pop_and_reduce(&mut states, &mut nodes, rule_kind);\n                nodes.push(new_node);\n                let temp_top_state = *states.last().unwrap();\n                let Some(new_state) = get_goto(temp_top_state, new_node_kind) else {\n                    return Err(quasiterminals.next().unwrap().try_into_terminal().ok());\n                };\n                states.push(new_state);\n            }\n\n            Action::Accept => {\n                return Ok(Json::try_from(nodes.pop().unwrap()).unwrap());\n            }\n\n            Action::Err => {\n                return Err(quasiterminals.next().unwrap().try_into_terminal().ok());\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Quasiterminal {\n    Terminal(Token),\n    Eof,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum QuasiterminalKind {\n    String = 0,\n    Num = 1,\n    Bool = 2,\n    LCurly = 3,\n    RCurly = 4,\n    LSquare = 5,\n    RSquare = 6,\n    Colon = 7,\n    Comma = 8,\n    Eof = 9,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum NonterminalKind {\n    Json = 0,\n    Obj = 1,\n    OptEntries = 2,\n    Entries = 3,\n    Entry = 4,\n    Expr = 5,\n    Arr = 6,\n    OptElements = 7,\n    Elements = 8,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum State {\n    S0 = 0,\n    S1 = 1,\n    S2 = 2,\n    S3 = 3,\n    S4 = 4,\n    S5 = 5,\n    S6 = 6,\n    S7 = 7,\n    S8 = 8,\n    S9 = 9,\n    S10 = 10,\n    S11 = 11,\n    S12 = 12,\n    S13 = 13,\n    S14 = 14,\n    S15 = 15,\n    S16 = 16,\n    S17 = 17,\n    S18 = 18,\n    S19 = 19,\n    S20 = 20,\n    S21 = 21,\n    S22 = 22,\n    S23 = 23,\n    S24 = 24,\n    S25 = 25,\n}\n\n#[derive(Debug)]\nenum Node {\n    Json(Json),\n    Obj(Obj),\n    OptEntries(OptEntries),\n    Entries(Entries),\n    Entry(Entry),\n    Expr(Expr),\n    Arr(Arr),\n    OptElements(OptElements),\n    Elements(Elements),\n    String(String),\n    Num(String),\n    Bool(String),\n    LCurly(String),\n    RCurly(String),\n    LSquare(String),\n    RSquare(String),\n    Colon(String),\n    Comma(String),\n}\n\n#[derive(Clone, Copy, Debug)]\nenum Action {\n    Shift(State),\n    Reduce(RuleKind),\n    Accept,\n    Err,\n}\n\n#[derive(Clone, Copy, Debug)]\nenum RuleKind {\n    R0 = 0,\n    R1 = 1,\n    R2 = 2,\n    R3 = 3,\n    R4 = 4,\n    R5 = 5,\n    R6 = 6,\n    R7 = 7,\n    R8 = 8,\n    R9 = 9,\n    R10 = 10,\n    R11 = 11,\n    R12 = 12,\n    R13 = 13,\n    R14 = 14,\n    R15 = 15,\n    R16 = 16,\n    R17 = 17,\n}\n\nfn pop_and_reduce(states: &mut Vec<State>, nodes: &mut Vec<Node>, rule_kind: RuleKind) -> (Node, NonterminalKind) {\n    match rule_kind {\n        RuleKind::R0 => {\n            let t0 = Box::new(Obj::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Json(Json::Obj(\n                    t0,\n                )),\n                NonterminalKind::Json\n            )\n        }\n        RuleKind::R1 => {\n            let t0 = Box::new(Arr::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Json(Json::Arr(\n                    t0,\n                )),\n                NonterminalKind::Json\n            )\n        }\n        RuleKind::R2 => {\n            nodes.pop().unwrap();\n            let entries_1 = Box::new(OptEntries::try_from(nodes.pop().unwrap()).unwrap());\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 3);\n            \n            (\n                Node::Obj(Obj {\n                    entries: entries_1,\n                }),\n                NonterminalKind::Obj\n            )\n        }\n        RuleKind::R3 => {\n            (\n                Node::OptEntries(OptEntries::None),\n                NonterminalKind::OptEntries,\n            )\n        }\n        RuleKind::R4 => {\n            let t0 = Box::new(Entries::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::OptEntries(OptEntries::Some(\n                    t0,\n                )),\n                NonterminalKind::OptEntries\n            )\n        }\n        RuleKind::R5 => {\n            let t0 = Box::new(Entry::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Entries(Entries::One(\n                    t0,\n                )),\n                NonterminalKind::Entries\n            )\n        }\n        RuleKind::R6 => {\n            let t2 = Box::new(Entry::try_from(nodes.pop().unwrap()).unwrap());\n            nodes.pop().unwrap();\n            let t0 = Box::new(Entries::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 3);\n            \n            (\n                Node::Entries(Entries::Many(\n                    t0,\n                    t2,\n                )),\n                NonterminalKind::Entries\n            )\n        }\n        RuleKind::R7 => {\n            let val_2 = Box::new(Expr::try_from(nodes.pop().unwrap()).unwrap());\n            nodes.pop().unwrap();\n            let key_0 = nodes.pop().unwrap().try_into_string_0().unwrap();\n            \n            states.truncate(states.len() - 3);\n            \n            (\n                Node::Entry(Entry {\n                    key: key_0,\n                    val: val_2,\n                }),\n                NonterminalKind::Entry\n            )\n        }\n        RuleKind::R8 => {\n            let t0 = Box::new(Obj::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Expr(Expr::Obj(\n                    t0,\n                )),\n                NonterminalKind::Expr\n            )\n        }\n        RuleKind::R9 => {\n            let t0 = Box::new(Arr::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Expr(Expr::Arr(\n                    t0,\n                )),\n                NonterminalKind::Expr\n            )\n        }\n        RuleKind::R10 => {\n            let t0 = nodes.pop().unwrap().try_into_string_0().unwrap();\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Expr(Expr::String(\n                    t0,\n                )),\n                NonterminalKind::Expr\n            )\n        }\n        RuleKind::R11 => {\n            let t0 = nodes.pop().unwrap().try_into_num_1().unwrap();\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Expr(Expr::Num(\n                    t0,\n                )),\n                NonterminalKind::Expr\n            )\n        }\n        RuleKind::R12 => {\n            let t0 = nodes.pop().unwrap().try_into_bool_2().unwrap();\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Expr(Expr::Bool(\n                    t0,\n                )),\n                NonterminalKind::Expr\n            )\n        }\n        RuleKind::R13 => {\n            nodes.pop().unwrap();\n            let elements_1 = Box::new(OptElements::try_from(nodes.pop().unwrap()).unwrap());\n            nodes.pop().unwrap();\n            \n            states.truncate(states.len() - 3);\n            \n            (\n                Node::Arr(Arr {\n                    elements: elements_1,\n                }),\n                NonterminalKind::Arr\n            )\n        }\n        RuleKind::R14 => {\n            (\n                Node::OptElements(OptElements::None),\n                NonterminalKind::OptElements,\n            )\n        }\n        RuleKind::R15 => {\n            let t0 = Box::new(Elements::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::OptElements(OptElements::Some(\n                    t0,\n                )),\n                NonterminalKind::OptElements\n            )\n        }\n        RuleKind::R16 => {\n            let t0 = Box::new(Expr::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 1);\n            \n            (\n                Node::Elements(Elements::One(\n                    t0,\n                )),\n                NonterminalKind::Elements\n            )\n        }\n        RuleKind::R17 => {\n            let t2 = Box::new(Expr::try_from(nodes.pop().unwrap()).unwrap());\n            nodes.pop().unwrap();\n            let t0 = Box::new(Elements::try_from(nodes.pop().unwrap()).unwrap());\n            \n            states.truncate(states.len() - 3);\n            \n            (\n                Node::Elements(Elements::Many(\n                    t0,\n                    t2,\n                )),\n                NonterminalKind::Elements\n            )\n        }\n    }\n}\n\nimpl QuasiterminalKind {\n    fn from_quasiterminal(quasiterminal: &Quasiterminal) -> Self {\n        match quasiterminal {\n            Quasiterminal::Terminal(terminal) => Self::from_terminal(terminal),\n            Quasiterminal::Eof => Self::Eof,\n        }\n    }\n\n    fn from_terminal(terminal: &Token) -> Self {\n        match terminal {\n            Token::String(_) => Self::String,\n            Token::Num(_) => Self::Num,\n            Token::Bool(_) => Self::Bool,\n            Token::LCurly(_) => Self::LCurly,\n            Token::RCurly(_) => Self::RCurly,\n            Token::LSquare(_) => Self::LSquare,\n            Token::RSquare(_) => Self::RSquare,\n            Token::Colon(_) => Self::Colon,\n            Token::Comma(_) => Self::Comma,\n        }\n    }\n}\n\nimpl Node {\n    fn from_terminal(terminal: Token) -> Self {\n        match terminal {\n            Token::String(t) => Self::String(t),\n            Token::Num(t) => Self::Num(t),\n            Token::Bool(t) => Self::Bool(t),\n            Token::LCurly(t) => Self::LCurly(t),\n            Token::RCurly(t) => Self::RCurly(t),\n            Token::LSquare(t) => Self::LSquare(t),\n            Token::RSquare(t) => Self::RSquare(t),\n            Token::Colon(t) => Self::Colon(t),\n            Token::Comma(t) => Self::Comma(t),\n        }\n    }\n}\n\nimpl Quasiterminal {\n    fn try_into_terminal(self) -> Result<Token, ()> {\n        match self {\n            Self::Terminal(terminal) => Ok(terminal),\n            Self::Eof => Err(()),\n        }\n    }\n}\n\nconst ACTION_TABLE: [[Action; 10]; 26] = [\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Shift(State::S6),\n        Action::Err,\n        Action::Shift(State::S4),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R0),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R1),\n    ],\n    [\n        Action::Shift(State::S17),\n        Action::Shift(State::S18),\n        Action::Shift(State::S19),\n        Action::Shift(State::S6),\n        Action::Err,\n        Action::Shift(State::S4),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Shift(State::S17),\n        Action::Shift(State::S18),\n        Action::Shift(State::S19),\n        Action::Shift(State::S6),\n        Action::Err,\n        Action::Shift(State::S4),\n        Action::Reduce(RuleKind::R14),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Shift(State::S17),\n        Action::Shift(State::S18),\n        Action::Shift(State::S19),\n        Action::Shift(State::S6),\n        Action::Err,\n        Action::Shift(State::S4),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Shift(State::S13),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R3),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Shift(State::S8),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R2),\n        Action::Err,\n        Action::Reduce(RuleKind::R2),\n        Action::Err,\n        Action::Reduce(RuleKind::R2),\n        Action::Reduce(RuleKind::R2),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R4),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Shift(State::S11),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R5),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R5),\n        Action::Err,\n    ],\n    [\n        Action::Shift(State::S13),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R6),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R6),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Shift(State::S3),\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R7),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R7),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R8),\n        Action::Err,\n        Action::Reduce(RuleKind::R8),\n        Action::Err,\n        Action::Reduce(RuleKind::R8),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R9),\n        Action::Err,\n        Action::Reduce(RuleKind::R9),\n        Action::Err,\n        Action::Reduce(RuleKind::R9),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R10),\n        Action::Err,\n        Action::Reduce(RuleKind::R10),\n        Action::Err,\n        Action::Reduce(RuleKind::R10),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R11),\n        Action::Err,\n        Action::Reduce(RuleKind::R11),\n        Action::Err,\n        Action::Reduce(RuleKind::R11),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R12),\n        Action::Err,\n        Action::Reduce(RuleKind::R12),\n        Action::Err,\n        Action::Reduce(RuleKind::R12),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Shift(State::S21),\n        Action::Err,\n        Action::Err,\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R13),\n        Action::Err,\n        Action::Reduce(RuleKind::R13),\n        Action::Err,\n        Action::Reduce(RuleKind::R13),\n        Action::Reduce(RuleKind::R13),\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R15),\n        Action::Err,\n        Action::Shift(State::S5),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R16),\n        Action::Err,\n        Action::Reduce(RuleKind::R16),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Reduce(RuleKind::R17),\n        Action::Err,\n        Action::Reduce(RuleKind::R17),\n        Action::Err,\n    ],\n    [\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Err,\n        Action::Accept,\n    ],\n];\n\nfn get_action(top_state: State, next_quasiterminal_kind: QuasiterminalKind) -> Action {\n    ACTION_TABLE[top_state as usize][next_quasiterminal_kind as usize]\n}\n\nconst GOTO_TABLE: [[Option<State>; 9]; 26] = [\n    [\n        Some(State::S25),\n        Some(State::S1),\n        None,\n        None,\n        None,\n        None,\n        Some(State::S2),\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        Some(State::S15),\n        None,\n        None,\n        None,\n        Some(State::S14),\n        Some(State::S16),\n        None,\n        None,\n    ],\n    [\n        None,\n        Some(State::S15),\n        None,\n        None,\n        None,\n        Some(State::S23),\n        Some(State::S16),\n        Some(State::S20),\n        Some(State::S22),\n    ],\n    [\n        None,\n        Some(State::S15),\n        None,\n        None,\n        None,\n        Some(State::S24),\n        Some(State::S16),\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        Some(State::S7),\n        Some(State::S9),\n        Some(State::S10),\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        Some(State::S12),\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n    [\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n    ],\n];\n\nfn get_goto(top_state: State, new_node_kind: NonterminalKind) -> Option<State> {\n    GOTO_TABLE[top_state as usize][new_node_kind as usize]\n}\n\nimpl TryFrom<Node> for Json {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Json(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Obj {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Obj(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for OptEntries {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::OptEntries(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Entries {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Entries(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Entry {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Entry(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Expr {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Expr(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Arr {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Arr(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for OptElements {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::OptElements(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl TryFrom<Node> for Elements {\n    type Error = Node;\n\n    fn try_from(node: Node) -> Result<Self, Self::Error> {\n        match node {\n            Node::Elements(n) => Ok(n),\n            _ => Err(node),\n        }\n    }\n}\n\nimpl Node {\n    fn try_into_string_0(self) -> Result<String, Self> {\n        match self {\n            Self::String(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_num_1(self) -> Result<String, Self> {\n        match self {\n            Self::Num(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_bool_2(self) -> Result<String, Self> {\n        match self {\n            Self::Bool(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_l_curly_3(self) -> Result<String, Self> {\n        match self {\n            Self::LCurly(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_r_curly_4(self) -> Result<String, Self> {\n        match self {\n            Self::RCurly(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_l_square_5(self) -> Result<String, Self> {\n        match self {\n            Self::LSquare(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_r_square_6(self) -> Result<String, Self> {\n        match self {\n            Self::RSquare(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_colon_7(self) -> Result<String, Self> {\n        match self {\n            Self::Colon(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n    \n    fn try_into_comma_8(self) -> Result<String, Self> {\n        match self {\n            Self::Comma(t) => Ok(t),\n            _ => Err(self),\n        }\n    }\n}\n",
)
